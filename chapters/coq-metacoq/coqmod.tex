\section{Towards Specifying the Meaning of Coq Modules}

% \subsection{A specification of Coq Modules}
Module systems are a feature of the ML family of languages; it allows
for massive abstraction and the reuse of code. In particular, Coq 
also has a module system that is influenced by ML modules, first 
implemented by Jacek ChrzÄ…szcz in 2003, then modified by Elie Soubrian
in 2010.

There are a few keywords when it comes to Coq Modules:
\begin{itemize}
\item A \textbf{structure} is an anynomous collection of definitions, and is the 
    underlying construct of modules. They contain \textbf{structure elements},
    which can be a
    \begin{itemize}
    \item constant definition
    \begin{minted}{coq}
        Definition a: bool := true.
    \end{minted}
    \item assumption
    \begin{minted}{coq}
        Axiom inconsistent: forall p: Prop, p.
    \end{minted}
    \item \textbf{module, module type, functors} recursively.
    \end{itemize}

\item A \textbf{module} is a structure given a name. It can be defined explicitly to be
    of a certain \textbf{module type}, which a named structure with possibly
    empty definitions.
\item A \textbf{module alias} is the association of a short name to an existing
    module.
\item A \textbf{functor} is a module defined with a parameter with a binder and
    a required type for the module supplied as an argument.
\end{itemize}

For a more precise definition of modules and related structures, please refer to
\href{https://coq.inria.fr/refman/language/core/modules.html}{Coq: Modules}.

\subsection{Conversion of Coq Terms}

To understand Coq Modules, we need to first understand the basic structure of
Coq. The core object in the language of Coq are terms. Terms of a type
correspond to a proof for a theorem as in the Curry-Howard correspondence.  The
syntax and semantics of Coq terms are as explained by the syntax,
\sidenote{\href{https://coq.inria.fr/refman/language/core/basic.html\#essential-vocabulary}
{Coq: Essential Vocabulary}} conversion (including reduction and expansion)
\sidenote{\href{https://coq.inria.fr/refman/language/core/conversion.html} {Coq:
Conversion}} and typing
\sidenote{\href{https://coq.inria.fr/refman/language/cic.html} {Coq: Typing}}
respectively. The evaluation of Coq terms are done under a Global Environment
$\Sigma$ containing definitions, and a local context $\Gamma$ containing
assumptions. Evaluation in Coq is known as conversion, the reflexive, transitive
closure of the various reduction rules that is defined, including the famous
$\beta$-reduction (function application).

The conversion relation is then defined with these parameters, from which we can
conclude nice properties on conversion, such as strong normalization, confluence
and decidability.

\subsection{Modules as second-class objects}
% \subsubsection{Modules as second-class objects}
However, Coq modules are not first class objects of the language and do not
participate in conversion themselves; i.e. there is no notion to "reduce" a
module. Plain modules in Coq can be treated as a named container of constant
and inductive definitions, including possibly nested modules; namespaced by a 
dot-separated string called a "path". This abstraction allows users to reuse
definitions, essentially importing another "global environment" into the current
one.

To further expand this possibility, module functors exist to be interfaces which
users can provide definitions for, by supplying a module definition. Functors
are therefore opaque second-class objects which is only useful when a module is
generated.

In this chapter, we formalize the semantics of the current implementation of Coq
Modules and formalize them at the level of TemplateCoq. Section
\ref{sec:semantics-of-modules} describes the semantics behind plain modules and
aliased modules, without functors.


% \section{Related Works}
\subsection{Related Works} Jacek Chrzaszcz's article in TPHOLs 2003
\sidecite{jacek2003} explains the motivation and choices for the implementation
of modules as a second class object and its interaction with terms as described
above.  Elie Soubiran's PhD Thesis on Coq Modules \sidecite{soubiran} describes
an extension of the Module system which only some features are implemented. The
\href{https://github.com/coq/coq/wiki/ModuleSystem}{ModuleSystem Wiki Page} on
Coq's official Github repository contains valuable information on the usage and
design decision of the Module system of Coq, including a list of open issues 
with Modules. In general, the issues do not compromise the correctness of the
type system implemented by Coq; instead, they should be viewed as possible areas
of improvements for Coq users.

Other slightly useful references include papers that explain modules in the ML
family of languages, specifically OCaml and to a certain extent, Standard ML.
On this note, Derek Dreyer wrote his PhD thesis \sidecite{dreyerphd} on
understanding and extending ML modules, and subsequently on implementing ML
modules in its most desirable form, applicative and first-order as a subset of a
small type system, $F_\omega$\sidecite{f-ing}. Other notable implementations
include that of CakeML \sidecite{cakeml}, a verified ML language and Standard ML
modules by MacQueen\sidecite{macqueen1984modules}. However, since the type
system of Coq is much stronger and sophisticated compared to ML languages, the
implementations also vary wildly and one can only refer to them for
inspirations.


% \begin{enumerate}
% \item Elie Soubrian's PhD Thesis on Coq Modules is the latest reference on 
% Coq Modules specifically.
% \item Since ML modules are the source of
% inspiration for Coq's Modules, it is also worthwhile to study
% Derek Dreyer's PhD Thesis on "Understanding and Evolving the ML Module 
% System".
% \item Recently, F-ing modules by Dreyer et. al. provides an 
% implementation of the ML module system in plain $F_\omega$, a strict 
% subset of CIC and hence PCUIC used in modern Coq.
% \item Standard ML also have modules.
% https://homepages.inf.ed.ac.uk/mfourman/teaching/mlCourse/notes/sml-modules.html
% Michael Fourman has lecture notes.
% \item David Macqueen (2002) wrote about implementint SML modules.
% \item CakeML has modules, but not functors. YK Tan (2015).
% \end{enumerate}

\section{Semantics of Modules}
\label{sec:semantics-of-modules}
From now onwards, we consider only non-parametrized modules.

There are two operations involving modules: how to define a module and how to
use a module. We will specify the behaviour, implementation and proof
obligations below.

Modules are containers for definitions that allow reuse. Definitions in Coq are
stored in a Global Environment. We first look at the structure of Global Environment:

\subsection{Global Environment}
The Global Environment in Coq can be understood as a table or a map. There are
three columns in the map: first is a canonical kername, second a pathname, and
finally, the definition object. Canonical kernames can be though of as unique
labels, and for the ease of understanding, as natural numbers 1, 2, 3 etc.
The pathname is a name which the user gives to the definition; it is of the form
of a dot-separated string, such as $M.N.a$. Finally, the definition object can
be:
\begin{itemize}

\item A \textbf{constant definition} to a Coq term, such as a lambda term,
application term, etc..

\item An \textbf{inductive definition} of a type.

\item A \textbf{module definition}. We consider a module to be inductively
defined as a list of constant, inductive, module or module signature
definitions. Alternatively, it can also be an alias to a previously defined
module (which may be an alias).

\item A \textbf{module signature definition} has the same structure as a module
definition, but instead of concrete definitions, it only specifies a name and a
type for each entry. It can be also an alias to a previously defined module
signature (which may be an alias).

\end{itemize}
The terms ``module type'' and ``module signature'' are used interchangeably.

\subsection{Plain Modules}
\label{sec:plainmodules}

\subsubsection{Behaviour and Implementation}

Modules can be thought of as a named global environment where the definitions
within it are namespaced by the module name. Therefore, its contents are not
modified during conversion/reduction.  In Coq, modules are second-class objects;
in other words, a module is not a term.  Its definition is stored and referred
to by a pathname and a kername.

Therefore, implementation wise, one need to ensure the correctness of "referring
to definition"; that is, when a definition within a module is referred to by its
pathname $M.N.a$, it will be fetched correctly from the table.

\subsubsection{Proof obligation}

We say the implementation of such a module is correct if the meta-theory of the
original system are unchanged and remains correct; that is the proofs go through
when terms can be defined within modules. Since the MetaCoq project has proven
various nice properties about conversion in Coq, our project on plain modules is
two-fold:

\begin{enumerate}
\item Ensure the correctness of the static semantics of Coq Modules
(well-typedness) during its definition.
\item Define the behaviour of access of definitions within Modules.
\end{enumerate}

Once these two are done, we can be sure that a Coq program with Modules
has all its terms well-defined (by (1)) and enjoys the nice properties of
conversion, since the additional terms defined in Modules fulfill (2).
This follows as our definition of Modules on the TemplateCoq level, is
eventually elaborated down into the PCUIC calculus the idea of modules and
aliasing do not exist anymore, they are flattened into the corresponding global
environment. The details of (2) are described in Section \ref{sec:using-modules}.

Concretely, if a module as below is defined while the Global Environment, which
stores definitions is denoted as $\Sigma$:
\begin{minted}{coq}
Module M.
    Definition a: nat := 0.
End M.
\end{minted}
Then the environment must have a new declaration added:
\[\Sigma := \Sigma :: \text{ModuleDeclaration}(M,
[\text{ConstantDeclaration}(M.a, nat, 0)])\]

So when $M.a$ is called, it must refer to the definition in the Global
Environment correctly.

\subsection{Aliased Modules}
Aliased modules are just a renaming of existing modules, which can be seen as
syntactic sugar for modules. Therefore, the correctness depends only on
implementing this internal referencing correctly.

\subsubsection{Behaviour and Implementation}
Suppose we have

\begin{minted}{coq}
Module N := M.
\end{minted}

Aliasing $N$ to $M$ and $M$ is a previously defined module (or an alias),
then any access path $N.X$ should be resolved similarly to
$M.X$ (note that since $M$ is possibly an alias as well, we do not require $N.X$
to resolve \emph{to} $M.X$). In the OCaml implementation, all definitions in $M$
can now be referred to by the pathnames $N.X$ in addition to $M.X$, while still
having the same kername.

\subsubsection{Proof Obligations}
\begin{enumerate}
\item Well-definedness: aliasing can only occur for well-defined modules. There
    cannot be self-alias and forward aliasing (aliasing something not yet defined).
\item The resolution of aliased modules is done at definition. If $N$ is aliased
    to $M$, then $N$ will immediately inherit the same kername as $M$. We will
    show this resolution is decidable and results in correct aliasing.
\end{enumerate}

\subsection{Using Modules}
\label{sec:using-modules}
As mentioned, the only way modules are used is during reduction or conversion
of a Coq term. In Coq, reduction and conversion are made up of smaller reduction
rules, such as $\beta, \delta,\zeta,\eta,\iota$ reductions. In particular, 
Modules are related only to $\delta$ reductions, which "replaces a defined
variable with its definition" 
\sidenote{\href{https://coq.inria.fr/refman/language/core/conversion.html} {Coq:
Conversion}}.

The correctness of $\delta$-reduction and conversion is a meta-theoretic
property, which is already shown to be correct and have properties such as 
normalization, confluence etc. in PCUIC \sidecite{coqcoqcorrect}. I will
contribute by expanding the definition of delta-conversion and expand the
existing proofs in the MetaCoq project that such properties continue to hold.