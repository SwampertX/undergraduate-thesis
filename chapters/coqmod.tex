\chapter{The Module System in Coq}
Module systems are  a feature of the ML family of languages; it allows
for massive abstraction and the reuse of code. In particular, Coq 
also has a module system that is influenced by ML modules, first 
implemented by Jacek ChrzÄ…szcz in 2003, then modified by Elie Soubrian
in 2010.

\section{A specification of Coq Modules}

\subsection{Conversion of Coq Terms}
To understand Coq Modules, we need to first understand the basic structure of 
Coq. The core object in the language of Coq are terms. Terms of a type
correspond to a proof for a theorem as in the Curry-Howard correspondence.
The syntax and semantics of Coq terms are as explained by the syntax
[insert link] and conversion rules [insert link] of Coq. The evaluation of Coq
terms are done under a Global Environment $\Sigma$ containing definitions,
and a local context $\Gamma$ containing assumptions. Evaluation in Coq is known
as conversion, the reflexive, transitive closure of the various reduction rules
that is defined, including the famous $\beta$-reduction (function application).

The conversion relation is then defined with these parameters, from which we can
conclude nice properties on conversion, such as strong normalization, confluence
and decidability.

\subsection{Modules as second-class objects}
However, Coq modules are not first class objects of the language and do not
participate in conversion themselves; i.e. there is no notion to "reduce" a
module. Plain modules in Coq can be treated as a named container of constant
and inductive definitions, including possibly nested modules; namespaced by a 
dot-separated string called a "path". This abstraction allows users to reuse
definitions, essentially importing another "global environment" into the current
one.

To further expand this possibility, module functors exist to be interfaces which
users can provide definitions for, by supplying a module definition. Functors
are therefore opaque second-class objects which is only useful when a module is
generated.

In this chapter, we formalize the syntax and semantics of the current
implementation of Coq and implement in the level of TemplateCoq. Section
\ref{sec:plainmodules} describes the implementation of plain modules
without functors.


\section{Related Works}
Elie Soubrian's PhD Thesis on Coq Modules is the latest reference on 
Coq Modules specifically. Since ML modules are the source of
inspiration for Coq's Modules, it is also worthwhile to study
Derek Dreyer's PhD Thesis on "Understanding and Evolving the ML Module 
System". Recently, F-ing modules by Dreyer et. al. provides an 
implementation of the ML module system in plain $F_\omega$, a strict 
subset of CIC and hence PCUIC used in modern Coq.

\section{Plain Modules}
\label{sec:plainmodules}

Plain modules are just saving declarations and definitions in a structure, in the
global context. Its contents are not modified during conversion/reduction.

In Coq, modules are second-class objects; in other words, a module is not a
term.  Its definition is stored and referred to by a canonical kername. We say
the implementation of such a module is correct if the metatheory of the original
system are unchanged and remains correct; that is the proofs go through when
terms can be defined within modules. Since the MetaCoq project has proven
various nice properties about conversion in Coq, our project on plain modules is
two-fold:
\begin{enumerate}
\item Ensure the correctness of the static semantics of Coq Modules
(well-typedness).
\item Define the behaviour of access of definitions within Modules.
\end{enumerate}

Once these two are done, we can be sure that a Coq program with Modules
has all its terms well-defined (by (1)) and enjoys the nice properties of
conversion, since the additional terms defined in Modules fulfill (2).
This follows as our definition of Modules on the TemplateCoq level, is
eventually elaborated down into the PCUIC calculus the idea of modules and
aliasing do not exist anymore, they are flattened into the corresponding global
environment.
