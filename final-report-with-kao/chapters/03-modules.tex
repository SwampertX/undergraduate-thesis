\chapter{The Module System of Coq}

This chapter aims to explain the syntax and semantics of the module system via
a generic description. Since the module system is well extended to integrate
with other extra-logical parts of Coq such as pretty printing, notation, and 
hint databases, which are beyond the scope of this project, I will
explain only a relevant subset of the module language in this section.
For a more precise definition of modules and related structures, please refer to
\href{https://coq.inria.fr/refman/language/core/modules.html}{Coq: Modules}.

\section{Abstract Syntax of Coq Modules}
The module system in Coq can be defined abstractly below, via a mutually
recursive definition:
\begin{itemize}
\item A \textbf{structure} is an anonymous collection of definitions, and is the 
    underlying construct of modules. They contain \textbf{structure elements},
    which can be
    \begin{itemize}
    \item an assumption,
    \begin{minted}{coq}
    Definition a: bool.
    \end{minted}
    \item a constant definition,
    \begin{minted}{coq}
    Definition b: bool := true.
    \end{minted}
    \item an inductive definition,
    \begin{minted}{coq}
    Inductive nat :=
    | O
    | S (n: nat).
    \end{minted}
    \item or a \textbf{module}, a \textbf{module type}, or a \textbf{functor}, recursively.
    \end{itemize}

\item
    A \textbf{module type} is a structure given a name.
    A \textbf{module} is also structure given a name, but all assumptions must
      be proven valid; that is, an element of the declared type is inhabited.
    When declaring a \textbf{module}, one can explicitly give a \textbf{module type}.
    \inputminted[firstline=11,lastline=22]{coq}{code/module_example.v}
\item A \textbf{module alias} is the association of a short name to an existing
    module.
\item A \textbf{functor} is a module defined with a parameter with a binder and
    a required type for the module supplied as an argument.
\end{itemize}



\subsection{Conversion of Coq Terms}

To understand Coq Modules, we need to first understand the basic structure of
Coq. The core object in the language of Coq are terms. Terms of a type
correspond to a proof for a theorem as in the Curry-Howard correspondence.  The
syntax and semantics of Coq terms are as explained by the syntax,
\sidenote{\href{https://coq.inria.fr/refman/language/core/basic.html\#essential-vocabulary}
{Coq: Essential Vocabulary}} conversion (including reduction and expansion)
\sidenote{\href{https://coq.inria.fr/refman/language/core/conversion.html} {Coq:
Conversion}} and typing
\sidenote{\href{https://coq.inria.fr/refman/language/cic.html} {Coq: Typing}}
rules respectively. The evaluation of Coq terms are done under a Global Environment
$\Sigma$ containing definitions, and a local context $\Gamma$ containing
assumptions. Evaluation in Coq is known as conversion, the reflexive, transitive
closure of the various reduction rules that is defined, including the famous
$\beta$-reduction (function application).

\subsection{Modules as second-class objects}
However, Coq modules are not first class objects of the language; meaning that
they are on another axis of the language and interacting with the core language
(consisting of terms) in limited ways only. This means that .
Plain modules in Coq can be treated as a named container of constant
and inductive definitions, including possibly nested modules; namespaced by a 
dot-separated string called a "path". This abstraction allows users to reuse
definitions, essentially importing another "global environment" into the current
one.

To further expand this possibility, module functors exist to be interfaces which
users can provide definitions for, by supplying a module definition. Functors
are therefore opaque second-class objects which is only useful when a module is
generated.

In this chapter, we formalize the semantics of the current implementation of Coq
Modules and formalize them at the level of TemplateCoq. Section
\ref{sec:semantics-of-modules} describes the semantics behind plain modules and
aliased modules, without functors.

\section{Semantics of Modules}
\label{sec:semantics-of-modules}
From now onwards, we consider only non-parametrized modules.

There are two operations involving modules: how to define a module and how to
use a module. We will specify the behaviour, implementation and proof
obligations below.

Modules are containers for definitions that allow reuse. Definitions in Coq are
stored in a Global Environment. We first look at the structure of Global Environment:

\subsection{Global Environment}
The Global Environment in Coq can be understood as a table or a map. There are
three columns in the map: first is a canonical kername, second a pathname, and
finally, the definition object. Canonical kernames can be though of as unique
labels, and for the ease of understanding, as natural numbers 1, 2, 3 etc.
The pathname is a name which the user gives to the definition; it is of the form
of a dot-separated string, such as $M.N.a$. Finally, the definition object can
be:
\begin{itemize}

\item A \textbf{constant definition} to a Coq term, such as a lambda term,
application term, etc..

\item An \textbf{inductive definition} of a type.

\item A \textbf{module definition}. We consider a module to be inductively
defined as a list of constant, inductive, module or module signature
definitions. Alternatively, it can also be an alias to a previously defined
module (which may be an alias).

\item A \textbf{module signature definition} has the same structure as a module
definition, but instead of concrete definitions, it only specifies a name and a
type for each entry. It can be also an alias to a previously defined module
signature (which may be an alias).

\end{itemize}
The terms ``module type'' and ``module signature'' are used interchangeably.

\subsection{Plain Modules}
\label{sec:plainmodules}

\subsubsection{Behaviour and Implementation}

Modules can be thought of as a named global environment where the definitions
within it are namespaced by the module name. Therefore, its contents are not
modified during conversion/reduction.  In Coq, modules are second-class objects;
in other words, a module is not a term.  Its definition is stored and referred
to by a pathname and a kername.

Therefore, implementation wise, one need to ensure the correctness of "referring
to definition"; that is, when a definition within a module is referred to by its
pathname $M.N.a$, it will be fetched correctly from the table.

\subsubsection{Proof obligation}

We say the implementation of such a module is correct if the meta-theory of the
original system are unchanged and remains correct; that is the proofs go through
when terms can be defined within modules. Since the MetaCoq project has proven
various nice properties about conversion in Coq, our project on plain modules is
two-fold:

\begin{enumerate}
\item Ensure the correctness of the static semantics of Coq Modules
(well-typedness) during its definition.
\item Define the behaviour of access of definitions within Modules.
\end{enumerate}

Once these two are done, we can be sure that a Coq program with Modules
has all its terms well-defined (by (1)) and enjoys the nice properties of
conversion, since the additional terms defined in Modules fulfill (2).
This follows as our definition of Modules on the TemplateCoq level, is
eventually elaborated down into the PCUIC calculus the idea of modules and
aliasing do not exist anymore, they are flattened into the corresponding global
environment. The details of (2) are described in Section \ref{sec:using-modules}.

Concretely, if a module as below is defined while the Global Environment, which
stores definitions is denoted as $\Sigma$:
\begin{minted}{coq}
Module M.
    Definition a: nat := 0.
End M.
\end{minted}
Then the environment must have a new declaration added:
\[\Sigma := \Sigma :: \text{ModuleDeclaration}(M,
[\text{ConstantDeclaration}(M.a, nat, 0)])\]

So when $M.a$ is called, it must refer to the definition in the Global
Environment correctly.

\subsection{Aliased Modules}
Aliased modules are just a renaming of existing modules, which can be seen as
syntactic sugar for modules. Therefore, the correctness depends only on
implementing this internal referencing correctly.

\subsubsection{Behaviour and Implementation}
Suppose we have

\begin{minted}{coq}
Module N := M.
\end{minted}

Aliasing $N$ to $M$ and $M$ is a previously defined module (or an alias),
then any access path $N.X$ should be resolved similarly to
$M.X$ (note that since $M$ is possibly an alias as well, we do not require $N.X$
to resolve \emph{to} $M.X$). In the OCaml implementation, all definitions in $M$
can now be referred to by the pathnames $N.X$ in addition to $M.X$, while still
having the same kername.

\subsubsection{Proof Obligations}
\begin{enumerate}
\item Well-definedness: aliasing can only occur for well-defined modules. There
    cannot be self-alias and forward aliasing (aliasing something not yet defined).
\item The resolution of aliased modules is done at definition. If $N$ is aliased
    to $M$, then $N$ will immediately inherit the same kername as $M$. We will
    show this resolution is decidable and results in correct aliasing.
\end{enumerate}

\subsection{Using Modules}
\label{sec:using-modules}
As mentioned, the only way modules are used is during reduction or conversion
of a Coq term. In Coq, reduction and conversion are made up of smaller reduction
rules, such as $\beta, \delta,\zeta,\eta,\iota$ reductions. In particular, 
Modules are related only to $\delta$ reductions, which "replaces a defined
variable with its definition" 
\sidenote{\href{https://coq.inria.fr/refman/language/core/conversion.html} {Coq:
Conversion}}.

The correctness of $\delta$-reduction and conversion is a meta-theoretic
property, which is already shown to be correct and have properties such as 
normalization, confluence etc. in PCUIC \sidecite{coqcoqcorrect}. I will
contribute by expanding the definition of delta-conversion and expand the
existing proofs in the MetaCoq project that such properties continue to hold.