\section{Conclusion}

\begin{frame}
  \frametitle{We have seen...}
  \begin{enumerate}
    \item Implementation of modules, typing rules, translation/elaboration.\pause
    \item Verification of the properties.\pause
    \item Second implementation that combines environments and modules.\pause
    \item Formal proof techniques necessary for verification.\pause
  \end{enumerate}
\end{frame}

\begin{frame}
  \frametitle{Future work}
  \begin{enumerate}
    \item Complete the modular environment rewrite.
    \item Functors (and higher-order functors)
    \item Document typing rules.
  \end{enumerate}
\end{frame}

\begin{frame}
  \frametitle{Related work - Coq}
  Previous implementations of Coq Modules: Courant, Chrąszcz, and
  Soubrian:
  \begin{enumerate}
    \item Courant added (second-class) modules, signature, and functors to Pure
    Type System (PTS).
    \item Chrąszcz implemented modules, signature, and functors in
    mainline Coq, and proved the conservativity of his extension.
    \item Soubrian implemented higher-order functions and unified modules and
    signatures with structures, and proposed dynamic naming scopes for modules.
  \end{enumerate}
\end{frame}

\begin{frame}
  \frametitle{Related work - ML Modules}
  
  \begin{enumerate}
    \item SML by Lillibridge, Harper et. al..
    \item OCaml by Leroy: applicative functors.
    \item CakeML came closest in verifying modules.
  \end{enumerate}
\end{frame}

\begin{frame}
  \frametitle{Thank you!}
  Questions?
\end{frame}