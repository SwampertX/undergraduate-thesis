\chapter{Previous Works}
\label{ch:previous-works}

Since Coq is influenced by the ML family of languages, the specification for
modules in Coq is very similar to that of OCaml. in this chapter, we review the
previous implementations of Coq modules, as well as relevant module systems in
other ML languages that this project can refer to. However, since the type
system of Coq is much stronger and more sophisticated compared to ML languages,
the implementations also vary wildly and one can only refer to them as
inspirations.

% To implement modules, we can study the previous implementation of modules in
% both Coq and related languages from the ML Family, such as Standard ML (SML)
% and OCaml.

% Things to explain: type system, mod sig fun, anonymous second class obj
% conservative ext

\section{Coq Module Implementations}
The earliest exploration of adding a module system to a Pure Type System (PTS)
% \footnote{PTS can be seen as a generalization of Barendregt's Lambda Cube, by
% defining type systems using a triple $(\mathscr{S},\mathscr{A},\mathscr{R})$
% representing sorts, axioms and rules of the type system respectively.}
, a
generalized type system subsuming Coq, was done by Judicaël Courant in his Ph.D.
thesis (\cite{courant1997module}). He designed the $MC$ Module Calculus system
which included modules, signatures, and functors for PTS and proved that the
extension is conservative\footnote{In proof theory, an extension of a formal
language is conservative if it cannot prove statements that are not already
provable in the base language.}. Modules in $MC$ are anonymous, second-class
objects with a specific set of reduction rules, and Courant has proven the
resulting system to have decidable type inference and the principal type
property.

Building on the idea of Courant, Jacek Chrąszcz designed the earliest
implementation of a module system in Coq in his Ph.D. thesis
(\cite{chrzkaszcz2004modules}), released with Coq version $7.4$. The module
system by Chrąszcz was a subset of that of Courant with some changes. Similar to
$MC$, modules, signatures, and functors are implemented together with
specialized reduction rules, but he argued that an anonymous module system does
not work well with the definition and rewriting system of Coq. Therefore, all
modules are named and the expression for modules in Coq is restricted only to
module paths. The core of Chrąszcz's thesis is the conservativity proof of the
module system extension over Coq, together with its associated syntax, typing
rules, and rewriting rules.

The most recent work on Coq's module system is Elie Soubrian's Ph.D. thesis
(\cite{soubiran}). He proposed many improvements to the system, among which a
few are already implemented, such as unifying modules and signatures with
structures, and higher-order functors. However, other features mentioned in the
thesis such as applicative functors, and namespaces allowing separate, dynamic
naming scopes for modules, are not yet implemented in the module system of Coq.

\section{Modules in ML Dialects}
\label{sec:ml-dialects}
Interestingly, the two main ML dialects today, OCaml and SML have different
approaches and semantics for modules. Modules are by default applicative
(generative functors are possible) in OCaml while generative in SML.

The module system of SML has evolved over the years, from the earliest account
by MacQueen (\cite{macqueen1984modules}) and Harper et. al. in terms of "strong
sum" types, to the "transparent" approach by Lillibridge (\cite{harper1994type}).
Harper and Lillibridge also developed first-order modules in SML eventually
using standard notions from type theory. Meanwhile, Leroy made progress on
applicative functors, modular module systems, and mutually recursive modules in
SML, then OCaml (\cite{leroy1994manifest,leroy1995applicative,leroy2000modular}).
On this note, Derek Dreyer wrote his Ph.D. thesis (\cite{dreyerphd}) on
understanding and extending ML modules, and subsequently implementing ML modules
in its most desirable form, applicative and first-order as a subset of a
relatively small type system, $F_\omega$ (\cite{f-ing}). Another related project
is CakeML (\cite{cakeml}) which verifies a subset of SML, however, modules are
unverified.

% \section{Knowledge Management in Proof Assistants}